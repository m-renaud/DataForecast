-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A sensible set of defaults for writing custom Preludes.
--   
--   A sensible set of defaults for writing custom Preludes.
@package protolude
@version 0.1.10

module Bifunctor
class Bifunctor p where bimap f g = first f . second g first f = bimap f id second = bimap id
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
first :: Bifunctor p => (a -> b) -> p a c -> p b c
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Bifunctor.Bifunctor (,)
instance Bifunctor.Bifunctor ((,,) x1)
instance Bifunctor.Bifunctor ((,,,) x1 x2)
instance Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
instance Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
instance Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
instance Bifunctor.Bifunctor Data.Either.Either
instance Bifunctor.Bifunctor Data.Functor.Const.Const

module Semiring
class Monoid m => Semiring m
one :: Semiring m => m
(<.>) :: Semiring m => m -> m -> m

-- | Alias for <a>mempty</a>
zero :: Monoid m => m

module Functor

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: a -> f b -> f a

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

module Either
maybeToLeft :: r -> Maybe l -> Either l r
maybeToRight :: l -> Maybe r -> Either l r
leftToMaybe :: Either l r -> Maybe l
rightToMaybe :: Either l r -> Maybe r
maybeToEither :: Monoid b => (a -> b) -> Maybe a -> b

module List
head :: (Foldable f) => f a -> Maybe a
ordNub :: (Ord a) => [a] -> [a]
sortOn :: (Ord o) => (a -> o) -> [a] -> [a]
list :: [b] -> (a -> b) -> [a] -> [b]
product :: (Foldable f, Num a) => f a -> a
sum :: (Foldable f, Num a) => f a -> a

module Bool
whenM :: Monad m => m Bool -> m () -> m ()
unlessM :: Monad m => m Bool -> m () -> m ()
ifM :: Monad m => m Bool -> m a -> m a -> m a
guardM :: MonadPlus m => m Bool -> m ()
bool :: a -> a -> Bool -> a

module Applicative
orAlt :: (Alternative f, Monoid a) => f a -> f a
orEmpty :: Alternative f => Bool -> a -> f a
eitherA :: (Alternative f) => f a -> f b -> f (Either a b)
purer :: (Applicative f, Applicative g) => a -> f (g a)
liftAA2 :: (Applicative f, Applicative g) => (a -> b -> c) -> f (g a) -> f (g b) -> f (g c)
(<<*>>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)

module Base
($!) :: (a -> b) -> a -> b
infixr 0 $!

module Monad

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: * -> *)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: a -> m a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: * -> *)

-- | the identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
mzero :: m a

-- | an associative operation
mplus :: m a -> m a -> m a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => forall a b. m a -> m b -> m b

-- | <tt><a>forever</a> act</tt> repeats the action infinitely.
forever :: Applicative f => f a -> f b

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <tt>filter</tt>
--   <tt><tt>filter</tt></tt> = <tt>(mfilter:: (a -&gt; Bool) -&gt; [a]
--   -&gt; [a]</tt> applicable to any <a>MonadPlus</a>, for example
--   <tt>mfilter odd (Just 1) == Just 1</tt> <tt>mfilter odd (Just 2) ==
--   Nothing</tt>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | <tt><a>guard</a> b</tt> is <tt><a>pure</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>empty</a> if <tt>b</tt> is <a>False</a>.
guard :: Alternative f => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
liftM' :: Monad m => (a -> b) -> m a -> m b
liftM2' :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b
(<$!>) :: Monad m => (a -> b) -> m a -> m b

module Show
class Print a
putStr :: (Print a, MonadIO m) => a -> m ()
putStrLn :: (Print a, MonadIO m) => a -> m ()
putText :: MonadIO m => Text -> m ()
putLText :: MonadIO m => Text -> m ()
instance Show.Print Data.Text.Internal.Text
instance Show.Print Data.Text.Internal.Lazy.Text
instance Show.Print Data.ByteString.Internal.ByteString
instance Show.Print Data.ByteString.Lazy.Internal.ByteString
instance Show.Print [GHC.Types.Char]

module Debug
undefined :: a

-- | <i>Warning: <a>error</a> remains in code</i>
error :: Text -> a

-- | <i>Warning: <a>trace</a> remains in code</i>
trace :: Print b => b -> a -> a

-- | <i>Warning: <a>traceM</a> remains in code</i>
traceM :: (Monad m) => Text -> m ()

-- | <i>Warning: <a>traceM</a> remains in code</i>
traceId :: Text -> Text

-- | <i>Warning: <a>traceIO</a> remains in code</i>
traceIO :: Print b => b -> a -> IO a

-- | <i>Warning: <a>traceShow</a> remains in code</i>
traceShow :: Show a => a -> b -> b

-- | <i>Warning: <a>traceShowId</a> remains in code</i>
traceShowId :: Show a => a -> a

-- | <i>Warning: <a>traceShowM</a> remains in code</i>
traceShowM :: (Show a, Monad m) => a -> m ()
notImplemented :: a

module Conv
class StringConv a b
strConv :: StringConv a b => Leniency -> a -> b
toS :: StringConv a b => a -> b
toSL :: StringConv a b => a -> b
data Leniency
Lenient :: Leniency
Strict :: Leniency
instance GHC.Enum.Bounded Conv.Leniency
instance GHC.Enum.Enum Conv.Leniency
instance GHC.Classes.Ord Conv.Leniency
instance GHC.Show.Show Conv.Leniency
instance GHC.Classes.Eq Conv.Leniency
instance Conv.StringConv GHC.Base.String GHC.Base.String
instance Conv.StringConv GHC.Base.String Data.ByteString.Internal.ByteString
instance Conv.StringConv GHC.Base.String Data.ByteString.Lazy.Internal.ByteString
instance Conv.StringConv GHC.Base.String Data.Text.Internal.Text
instance Conv.StringConv GHC.Base.String Data.Text.Internal.Lazy.Text
instance Conv.StringConv Data.ByteString.Internal.ByteString GHC.Base.String
instance Conv.StringConv Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString
instance Conv.StringConv Data.ByteString.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString
instance Conv.StringConv Data.ByteString.Internal.ByteString Data.Text.Internal.Text
instance Conv.StringConv Data.ByteString.Internal.ByteString Data.Text.Internal.Lazy.Text
instance Conv.StringConv Data.ByteString.Lazy.Internal.ByteString GHC.Base.String
instance Conv.StringConv Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Internal.ByteString
instance Conv.StringConv Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString
instance Conv.StringConv Data.ByteString.Lazy.Internal.ByteString Data.Text.Internal.Text
instance Conv.StringConv Data.ByteString.Lazy.Internal.ByteString Data.Text.Internal.Lazy.Text
instance Conv.StringConv Data.Text.Internal.Text GHC.Base.String
instance Conv.StringConv Data.Text.Internal.Text Data.ByteString.Internal.ByteString
instance Conv.StringConv Data.Text.Internal.Text Data.ByteString.Lazy.Internal.ByteString
instance Conv.StringConv Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
instance Conv.StringConv Data.Text.Internal.Text Data.Text.Internal.Text
instance Conv.StringConv Data.Text.Internal.Lazy.Text GHC.Base.String
instance Conv.StringConv Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
instance Conv.StringConv Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
instance Conv.StringConv Data.Text.Internal.Lazy.Text Data.ByteString.Lazy.Internal.ByteString
instance Conv.StringConv Data.Text.Internal.Lazy.Text Data.ByteString.Internal.ByteString

module Exceptions
hush :: Alternative m => Either e a -> m a
note :: (MonadError e m, Applicative m) => e -> Maybe a -> m a
tryIO :: MonadIO m => IO a -> ExceptT IOException m a

module Panic

-- | Uncatchable exceptions thrown and never caught.
data FatalError
FatalError :: Text -> FatalError
[msg] :: FatalError -> Text
panic :: Text -> a
instance GHC.Show.Show Panic.FatalError
instance GHC.Exception.Exception Panic.FatalError

module Unsafe
unsafeHead :: [a] -> a
unsafeTail :: [a] -> [a]
unsafeInit :: [a] -> [a]
unsafeLast :: [a] -> a
unsafeFromJust :: Maybe a -> a
unsafeIndex :: [a] -> Int -> a
unsafeThrow :: Exception e => e -> a

module Protolude
identity :: a -> a
map :: Functor f => (a -> b) -> f a -> f b
(&) :: a -> (a -> b) -> b
infixl 1 &
uncons :: [a] -> Maybe (a, [a])
unsnoc :: [x] -> Maybe ([x], x)
applyN :: Int -> (a -> a) -> a -> a
print :: (MonadIO m, Show a) => a -> m ()
throwIO :: (MonadIO m, Exception e) => e -> m a
throwTo :: (MonadIO m, Exception e) => ThreadId -> e -> m ()
foreach :: Functor f => f a -> (a -> b) -> f b
show :: (Show a, StringConv String b) => a -> b
pass :: Applicative f => f ()
guarded :: (Alternative f) => (a -> Bool) -> a -> f a
guardedA :: (Functor f, Alternative t) => (a -> f Bool) -> a -> f (t a)
type LText = Text
type LByteString = ByteString
